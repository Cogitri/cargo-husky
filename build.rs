use fs::File;
use io::Read;
use os::unix::fs::OpenOptionsExt;
use path::{Path, PathBuf};
use std::{env, fmt, fs, io, os, path};

enum Error {
    GitDirNotFound,
    Io(io::Error),
}

type Result<T> = std::result::Result<T, Error>;

impl From<io::Error> for Error {
    fn from(error: io::Error) -> Error {
        Error::Io(error)
    }
}

impl fmt::Debug for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let msg = match self {
            Error::GitDirNotFound => {
                let cwd = env::current_dir()
                    .and_then(|d| fs::canonicalize(d))
                    .map(|p| p.to_string_lossy().to_string())
                    .unwrap_or_else(|e| format!("{}", e));
                format!(
                    ".git directory was not found in {} or its parent directories (target dir: {})",
                    cwd,
                    env::var("CARGO_TARGET_DIR").unwrap_or("".to_string()),
                )
            }
            Error::Io(inner) => format!("IO error: {}", inner),
        };
        write!(f, "{}", msg)
    }
}

fn resolve_gitdir() -> Result<PathBuf> {
    let mut dir = env::current_dir()?;
    if !dir.has_root() {
        dir = fs::canonicalize(dir)?;
    }
    loop {
        let gitdir = dir.join(".git");
        if gitdir.is_dir() {
            return Ok(gitdir);
        }
        if gitdir.is_file() {
            let mut buf = String::new();
            File::open(gitdir)?.read_to_string(&mut buf)?;
            let gitdir = PathBuf::from(buf.trim_right_matches("\n\r"));
            if !gitdir.is_dir() {
                return Err(Error::GitDirNotFound);
            }
            return Ok(gitdir);
        }
        if !dir.pop() {
            return Err(Error::GitDirNotFound);
        }
    }
}

fn write_script<W: io::Write>(w: &mut W) -> Result<()> {
    writeln!(
        w,
        r#"#!/bin/sh
#
# This hook was set by cargo-husky v{}: {}
# Generated by script {}{}build.rs
# Generated at {}
#

set -e
cargo test
"#,
        env::var("CARGO_PKG_VERSION").unwrap_or("".to_string()),
        env::var("CARGO_PKG_HOMEPAGE").unwrap_or("".to_string()),
        env::var("CARGO_MANIFEST_DIR").unwrap_or("".to_string()),
        path::MAIN_SEPARATOR,
        env::var("CARGO_TARGET_DIR").unwrap_or("".to_string()),
    )?;
    Ok(())
}

#[cfg(target_os = "win32")]
fn create_script(path: &Path) -> io::Result<File> {
    fs::create(path)
}

#[cfg(not(target_os = "win32"))]
fn create_script(path: &Path) -> io::Result<File> {
    fs::OpenOptions::new()
        .create(true)
        .write(true)
        .mode(0o755)
        .open(path)
}

fn install(hook: &str) -> Result<()> {
    let hook_path = {
        let mut p = resolve_gitdir()?;
        p.push("hooks");
        p.push(hook);
        p
    };
    let mut f = create_script(hook_path.as_path())?;
    write_script(&mut f)?;
    Ok(())
}

fn main() -> Result<()> {
    install("pre-push")
}
